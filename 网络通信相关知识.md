## 五大IO模型
阻塞IO 非阻塞IO IO多路复用 信号驱动IO 异步IO

## 零拷贝
1. 传统缓冲区（多次拷贝）
假设从文件读取数据并发送到网络：

磁盘 → 内核缓冲区（DMA 拷贝）

内核缓冲区 → 用户缓冲区（CPU 拷贝）

用户缓冲区 → Socket 内核缓冲区（CPU 拷贝）

Socket 缓冲区 → 网卡（DMA 拷贝）

问题：步骤 2 和 3 的 CPU 拷贝是冗余的，消耗资源且延迟高。

2. 零拷贝（减少拷贝）需要特定的操作系统和硬件才能实现
以 Linux 的 sendfile 系统调用为例：

磁盘 → 内核缓冲区（DMA 拷贝）

内核缓冲区 → Socket 缓冲区（CPU 拷贝）

Socket 缓冲区 → 网卡（DMA 拷贝）

优化点：跳过了用户空间的中间拷贝，减少一次 CPU 拷贝和上下文切换。

- 问题：为什么传统缓存区不能直接拷贝到对应套接字缓存区？
1. 并发访问与数据一致性：若同一时间多个进程读写同一个内核缓存区，可能会导致数据冲突。为避免这种情况只能通过上锁方式实现。
2. 数据结构不匹配问题：操作系统中数据以页面缓存形式存储，且物理内存不连续，而tcp段或ip包需要重组为连续的符合协议要求的内存块，因此可能需要多次dma操作才能拷贝到连续的socket缓冲区。利用DMA引擎可以从多个非连续内存区域之间读取到连续数据。

- 实现关键：
````c++
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
````

## 进程间通信的方法
- 管道：用于父子进程和兄弟进程之间使用的单向通信。
- 共享内存：由一个线程申请的内存区，多个进程互斥共享
- 消息队列：维护一个共享链表顺序执行读写操作

- 信号量：用于进程间同步（非数据传输）
- - sem_t
定义：sem_t是 POSIX 线程库（<semaphore.h>）中定义的信号量类型，用于多线程或多进程间的同步操作。信号量是一个整型计数器，通过原子操作（sem_post 增加、sem_wait 减少）实现线程间的协调。

使用方法：
````c++
	sem_t sem; 
    sem_init(&sem, false, 0);                                               // false指的是 不设置进程间共享
    // 开启线程
    thread_ = std::shared_ptr<std::thread>(new std::thread([&]() {
        tid_ = CurrentThread::tid();                                        // 获取线程的tid值
        sem_post(&sem);														// 信号量值 +1，唤醒主线程
        func_();                                                            // 开启一个新线程 专门执行该线程函数
    }));
    sem_wait(&sem); // 主线程在次阻塞等待子线程sem_post(&sem);
````

- 套接字（socket）：基于网络的通信机制，支持跨机器进程通信
定义：可用于不同机器之间的进程通信，对于接受外部连接需要用::accept方法获取外部连接套接字。通过不同io模型监听事套接字对应的内核缓冲区判断读写事件，写事件用write方法，读事件使用read方法。

## 高性能网络架构
首先理解网络架构，首先要知道网络架构完成了什么。
以epoller为例，
1. 在客户端建立连接后，发送一个可读事件到服务端的内核接受缓存区。
2. 随后subloop中的监听器会监听到文件描述符状态发生改变，并将文件描述符对应的事件对象放入就绪队列中。
3. 根据就绪队列中不同的事件对象回调不同的handle方法，主要有处理读、写、错误、关闭事件。
4. 对于读事件，handle会将数据从文件描述符对应的内核接受缓存区读到线程内部的读缓存区；写事件稍微复杂些，会先尝试将数据写入内核的发送缓存区，如果一次性写不完会临时保存在线程内部的写缓存区，并在监听器上更新文件描述符的状态对写事件感兴趣，确保数据全部被发送。

网络架构包含的三大内容：
- IO事件监听
- 数据拷贝
- 数据处理和计算

网络通信中划分的两种体系结构：
- thread-based architecture（基于线程的架构）早期使用现在已经淘汰
- event-driven architecture（事件驱动模型）

理解：基于事件驱动模型实际上就可以理解为：在一个循环中，有个监听器在每次循环中监听多个连接中的事件，并将触发的事件放入一个就绪队列中，然后调用这些触发事件的回调函数一一处理。Reactor模型就是采用的基于事件驱动模型。
