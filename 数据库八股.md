# 数据库基础知识总结
## ER图 实体联系图
- **实体：** 主要指业务对象，如校园中的教师、学生、课程
- **属性：** 某个实体拥有的属性，如学生的姓名、年龄、学号等等
- **联系：** 实体之间的关系，用棱形表示，如选课、选导师等

## 主键和外键有什么区别？
- **主键：** 用于唯一标识一个元组，一个表中只能有一个主键
- **外键：** 用于关联其他表，外键是其他表的主键，可有多个

## 为什么不推荐外键与级联？
- 级联是指外键约束的扩展规则（在改删操作时），常见有CASCADE（同步更新）、SET NULL（置空）、NO ACTION（不做任何处理）
1. 增加了复杂性，每次做delete或update都必须考虑外键约束
2. 增加了额外操作，每次修改操作后需要去检查其他表，来保证数据一致性和正确性
3. 对分库分表不友好
- 例子
-  - 删同步更新：1.禁止插入不存在客户id的订单；2.删除客户时同步删除订单
````sql
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(100)
);
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id) ON DELETE CASCADE
);
````
-  -  更新同步:1.部门id更新自动修改员工表；2.禁止删除有员工的部门
````sql
CREATE TABLE departments (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);
CREATE TABLE employees (
    emp_id INT PRIMARY KEY,
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES departments(dept_id) ON UPDATE CASCADE
);
````

## 什么是分库分表？
**定义：** 分库分表是一种数据库优化策略，旨在将单库单表的庞大数据拆分到多库多表中，来解决性能瓶颈、存储压力和高并发问题。
- 分库：按照业务模块划分数据，例如：用户表、订单表、商品表划分到不同的数据库中。
- - 水平划分：按照数据范围或哈希规则划分统一业务的数据，例如根据用户id按取模分到不同库
- 分表：按照字段属性分表，主要是将基本信息和扩展信息分离
- - 水平划分：按行拆分表，如按月拆分订单表

## drop、delete、truncate区别
drop是直接将整个表删除
truncate删除表中的数据，下次插入时自增id从1开始
delete根据where筛选的元组进行删除

# MySQL
## 什么是关系型数据库？
字面意思就是在关系模型基础上根据不同实体之间的联系建立起来的数据库。

## MySQL字段类型
- **数值类型** 整型：TINYINT\SMALLINT\MEDIUMINT\INT\BIGINT 浮点型：FLOAT\DOUBLE 定点型：DECIMAL
- **字符串型** CHAR\VARCHAR\TXTE\BLOB
- **日期时间类型** YEAR\TIME\DATE\DATETIME\TIMESTAMP

## CHAR VARCHAR的区别
- CHAR 定长字符串，长度不够会填充空格，检索时会去掉。 适用于长度较短或长度差不多的字符串（身份证、电话号码）
- VARCHAR 变长字符串，存储时需要1或2个额外字节记录字符串长度，检索时不需要额外处理，例如用户昵称、文章标题
- CHAR(n) VARCHAR(n) 都是指最大记录长度为n

## NULL与''的区别是什么？
NULL 和 '' (空字符串) 表示不同的含义，并在数据库中有着不同的行为。NULL 代表缺失或未知的数据，而 '' 表示一个已知存在的空字符串。它们的主要区别如下：
1. 含义：
   - NULL代表一个不确定的值，不等于任何值包括本身，`selete NULL = NULL; `结果是`NULL`，而不是true或false.但有些操作会将NULL视为同一类别，DISTINCT\GROUP BY\ORDER BY.
   - ''空字符串代表一个已知值
2. 存储空间
   - NULL 的存储空间占用取决于数据库的实现，通常需要一些空间来标记该值为空。
   - ''的存储空间占用通常较小，因为它只存储一个空字符串的标志，不需要存储实际的字符。
3. 比较运算
   - 因为NULL代表着不确定，因此与任何值比较结果都是NULL，必须用IS NULL\IS NOT NULL
   - ''可以像其他字符串一样进行比较
4. 聚合函数
   -  大多数聚合函数MAX\SUM\MIN\AVG都会忽略NULL值，而COUNT(*)会记录NULL行，COUNT(列名)则不会
   -  ''会被计算

## MySQL 索引
- 定义：索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。
- 作用：善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。
- 数据库一般使用B+树建立索引

### 索引的优缺点
- 优点：1.使用索引可以大大加快检索速度，减少io次数 2.通过创建唯一性索引可以保证数据表中每一行的唯一性
- 缺点：1.创建和维护索引需要耗费时间。当对表中数据进行修改时，如果数据有索引也需要动态修改 2.索引使用物理文件存储，也会耗费一定空间

### B树与B+树的区别
1. B树中每个节点即存放索引也存放数据，而在B+树中非叶子节点存放索引，叶子节点存放索引和数据
2. B树每个节点相互独立，而B+树叶子节点是一条单向有序链表
3. B+树具有更稳定的查询效率，由于节点数据存放差异，在检索过程中，B树可能提前终止，而B+树都是从根节点到叶子节点
4. 范围查询时，B树需要中序遍历范围内的所有索引，而B+树只需要两次二分查找到上下限。B+树非叶子节点只涉及到索引因此单页存储索引数目多，io次数少

### 索引的类型
按照数据结构维度划分：
- BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。
- 哈希索引：类似键值对的形式，一次即可定位。
- RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR、TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

按照底层存储方式角度划分：
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分：
- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。
- 普通索引：仅加速查询。
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）。
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR、TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。
- 前缀索引：对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。




### 最左匹配原则
最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。
- 例子
````sql
CREATE TABLE `student` (
  `id` int NOT NULL,
  `name` varchar(100) DEFAULT NULL,
  `class` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `name_class_idx` (`name`,`class`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;


# 可以命中索引
SELECT * FROM student WHERE name = 'Anne Henry';
EXPLAIN SELECT * FROM student WHERE name = 'Anne Henry' AND class = 'lIrm08RYVk';
# 无法命中索引
SELECT * FROM student WHERE class = 'lIrm08RYVk'; # 匹配不了最左边的name
````

- 再来看一个常见的面试题：如果有索引 联合索引（a，b，c），查询 a=1 AND c=1 会走索引么？c=1 呢？b=1 AND c=1 呢？
- 查询 a=1 AND c=1：根据最左前缀匹配原则，查询可以使用索引的前缀部分。因此，该查询仅在 a=1 上使用索引，然后对结果进行 c=1 的过滤。查询 c=1：由于查询中不包含最左列 a，根据最左前缀匹配原则，整个索引都无法被使用。查询 b=1 AND c=1：和第二种一样的情况，整个索引都不会使用。

## MySQL事务
定义：事务可以理解为一次业务功能需要对数据库先后进行多条`修改的sql语句`，那么这些sql语句都修改成功要么都失败，只有这两种可能。

- 关系型数据库都具有ACID特性
1.  Atomic 原子性，即事务是最小执行单位不可能分离
2.  consistency 一致性，事务前后数据修改总量必须一致
3.  isolation 隔离性，在并发访问数据库时，一个用户的事务不能被其他事务干扰
4.  duration 持久化，一个事务一旦被提交，这些修改就应该永久的保存在数据库中
5.  

### 并发事务带来了什么问题？
在并发访问数据库的情况下，可能存在多个事务同时对某个数据修改，那么就可能导致以下问题：
1. 脏读
一个事务对数据进行了修改，但还未提交，此时这个数据对其他事务可见，那么当第一个事务回滚时就会导致其他事务读取到脏数据。
2. 丢失修改
两个事务同时读取一个数据，并且先后对这个数据修改，就导致其中一个事务丢失了修改结果
3. 不可重复读
同一个事务中两次读取未操作的数据发生了数据内容修改或记录数减少的变化。
1. 幻读
事务先后进行两次查询操作查到的记录数`增加`了

#### 不可重复读与幻读的区别
不可重复读强调的是前后查询字段内容修改或记录数变化,幻读强调的是两次查询语句的记录数增多
- 幻读其实可以看成不可重复读的特俗情况，单独拎出来是因为解决方案不一致
- 例子：delete或update时，只需要对已有数据加上记录锁即可，而insert操作需要插入新记录，而记录锁只能对已有数据上锁，因此还需要间隙锁

### SQL标准定义了哪些事务隔离级别？
- READ-UNCOMMITTED(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ-COMMITTED(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE-READ(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- SERIALIZABLE(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

### 并发事务的控制方式有哪些？
锁和MVCC

#### 锁
1. 锁
- - 种类划分：读（共享）锁、写（排他）锁
- - 粒度划分：
- - -   表级锁（粒度最大的锁，针对非索引字段加的锁，对当前操作的整张表加锁，简单资源开销小但高并发条件下效率低，冲突概率高，不会有死锁，与存储引擎无关）
- - -   行级锁（粒度最小，针对索引字段加的锁，并发条件下冲突最低，加锁开销大，会出现死锁，与存储引擎有关）
  
2. 行级锁的使用有什么注意事项？
行级锁针对索引加的锁，表级锁针对非索引字段加的锁。因此在执行update、delete语句时，如果where条件中字段没有命中唯一索引或索引失效，就会全表扫描对整个表加锁！！！


3. 行级锁
- - 记录锁 属于单行的锁，锁住已经存在的锁
- - 间隙锁 锁定一个范围，不包括记录本身，避免插入
- - 临键锁（记录锁+间隙锁）锁住一个范围加记录本身，为了解决幻读

4. 意向锁：在想要获取表锁时，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。也分为意向共享锁、排他锁   
- 实现原理：由数据引擎自己维护，用户无法手动获取意向锁，在为数据行加共享、排他的`行级锁之前`，会先获取该数据行所在数据表的对应意向锁。那么在获取表级锁时，对于读表级锁需要判断表内有没有加排他意向锁，对于写表级锁时需要判断表内有没有加任何的意向锁。

#### MVCC
- MVCC 多版本并发控制 主要依赖于隐藏字段、read view、undo_log
- - 隐藏字段：每行都有对应的三个隐藏字段，分别记录该行的最后修改事务id、undo_log、行索引
- - ReadView：用来做可见性判断的，里面主要有四个重要字段，分别表示下一个待创建事务ID、小于该ID可见、活跃事务ID、当前事务ID
- - undo_log：用来记录事务中对行的修改操作。主要功能是回滚事务和辅助实现MVCC

#### 数据可见性算法的实现 （确保查询到的记录版本号必须是在`当前事务`执行前就提交）
在MVCC中，每个select语句执行之前，都会记录当前事务的一个readview（快照），快照是根据创建的时间将所有事务划分为提交与未提交两种状态，在查询每一行数据时都会根据该行最后一个修改事务ID去与快照中保存的3个重要字段做一个判断，小于当前值可见、大于等于待创建事务ID不可见、在活跃列表中的事务ID不可见。
- 如果不可见，就从该行隐藏字段中取出回滚指针指向的undo_log，并把undo_log中的事务ID取出重新开始判断。直到找到满足的快照版本或返回空。

#### RC和RR隔离级别下MVCC的差异
- 在读已提交情况下，只需确保读到的最新数据是已提交事务修改的，那么只需要在每次selete查询前都快照
- 重复读确保的是两次select操作读到的数据一致，那么也就是说所有相关行在事务过程中没有被活跃事务修改，因此只需要在第一次select操作前生成一次ReadView即可。

#### 当前读与快照读有什么区别？
- 当前读顾名思义就是通过上锁的方式读取行数据
````sql
# 对读的记录加一个X锁
SELECT...FOR UPDATE
# 对读的记录加一个S锁
SELECT...LOCK IN SHARE MODE
# 对读的记录加一个S锁
SELECT...FOR SHARE
# 对修改的记录加一个X锁
INSERT...
UPDATE...
DELETE...
````

- 快照读只能针对单纯的select语句，具体而言在对每一个数据行读取时会判断历史版本号，从最新的历史版本号对应的事务ID开始，直到可见为止。快照读适合一些数据一致性要求不高，但追求极致性能的场景。


## MySQL性能怎么优化？
前置知识：
- 可以使用 EXPLAIN 命令来分析 SQL 的 执行计划,EXPLAIN 并不会真的去执行相关的语句，而是通过`查询优化器`对语句进行分析，找出最优的查询方案，并显示对应的信息。
````sql
mysql> EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | cus_order | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 997572 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set, 1 warning (0.00 sec)
````



建议从下面几点回答：
- 通过使用监听工具定位慢SQL位置，并使用explain得到SQL语句的执行计划。
- 对于执行计划，我一般会着重查看这几个字段：1.type字段，表示MySQL的访问类型，必须避免ALL全表查询方式，并尽量优化SQL语句达到range级别的索引范围查询。2.key与possible_keys字段，表示索引的使用情况，如果possible_keys有值，但key未命中，说明索引失效需要分析原因，对于联合索引必须满足最左前缀匹配原则。3.extra字段，表示附加操作信息，可以查看是否使用额外排序或创建临时表的情况来优化SQL。
- 分析完执行计划后，考虑从三个方面优化：
  - 索引优化：创建原则、覆盖索引、最左前缀匹配原则
  - 表结构优化：优化表属性字段类型，如在满足需求的条件下优先选择占用空间小的类型。如使用timestamp（4B）替换datetime（8B）
  - SQL优化：避免order by、group by等语句
- 如果上述优化还不能达到要求，这时就可以用
  - 读写分离：将数据复制到多个数据库中，其中只有一个主库和多个从库，并且修改操作只能写入主库binlog中，而且binlog的数据会发送到从库的relaylog中，从库会将relog的数据同步到本地（也就是在执行一篇SQL）。对于读操作任选一个从库即可。`如何主从延迟避免`，从binlog中同步数据到从库需要时间，这时候读就可能导致数据不一致性问题，解决方案：就是强制将读请求路由到主库处理。
  - 分库分表：将一个大量的单表数据先后进行分库和分表操作，在提升性能的同时提高了并发度，但是成本太高，非必要不推荐。分库来说垂直分库把用户表、订单表等划分到不同库中，水平分库把同一个表按照一定的规则拆分到不同数据库中。分表来说水平分表就是分行，垂直拆分就是分列，如将用户的额外信息拆分成一个表。
  - 冷热数据分离：数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据高性能存储介质中。划分可以根据：时间维度（一年前的订单冷数据，一年内热数据）、访问频率（热点新闻、热销产品）








